{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/post/Docker-K8S-1",
    "result": {"data":{"markdownRemark":{"frontmatter":{"title":"Docker & K8S (1)","date":"September 18th, 2019"},"html":"<hr>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.59574468085106%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACOklEQVQoz4WPbUjTURTG73+TCkIiAvGD0SiLfaloPDvbXJtEFmYvagqBGkURJWUImZSgUs4PUfrBshexF0Jw0gulQTClsmXWFw0sR0X0QrjNmebSzbnaiSt/RUrqwMO93HPu73mOELOKmUXvh4mpk5m1111BR261f2RrpY/Tyrx86ELA094T2rGnZlDYSwcUOffPkgPtvSGN+3VYvP06ad/p8HFh/RA7O3/8rGsdjeZU+7no0tBHZtbI2UevQv8HVjWPxJXfHBbnW0ePp5d72dk5FnnaF+ZuTzhW2TQc21LhDY+Hf+n7PkVE24tx5S8IATOaWoHeawTeibIbw00y0S33WMTVE+KO3lCs9u73aEaFl7vehHPvPBsT97vHtXMBFZMKLMjPF8cczdqu/gm5si27yhctODvIDQ+DkxcfjE6klg5wSeO3l8y8UJpfa3mszA4kNX2RDQUGgzCsg9h4oCWuzMni3vPg/r21fpapsk57ufhyIMAc0UnY5xgrmdl5M3+nJR9W/uGyfJV+jchL14tke4n4EuLVHR62uvrZzswJJx2NIjFeiOSkxYqJSDNXwjoCiAADASkEXCFgk5mMNiNMmxMWzTfoEuPTkpbMs63QLduQYlkvZzMIOExAMQFrCcgkwELANgl8QkARAQ4VfoaAqwS4TUbjOYvJXGO12q0Ws+WUmUzSrI2ABgKOElBIQD0BTpVxWwKzCEglYJ+qgwRsV1PkqM4L1NOuptlFwFICjshtCNit9k/8BuTdKK6SzgISAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1*6NVMEmo0qDcQjpXcXI8dtg\"\n        title=\"1*6NVMEmo0qDcQjpXcXI8dtg\"\n        src=\"/static/353855dec58fcaa1477e90a869b30ad0/1d69c/1*6NVMEmo0qDcQjpXcXI8dtg.png\"\n        srcset=\"/static/353855dec58fcaa1477e90a869b30ad0/4dcb9/1*6NVMEmo0qDcQjpXcXI8dtg.png 188w,\n/static/353855dec58fcaa1477e90a869b30ad0/5ff7e/1*6NVMEmo0qDcQjpXcXI8dtg.png 375w,\n/static/353855dec58fcaa1477e90a869b30ad0/1d69c/1*6NVMEmo0qDcQjpXcXI8dtg.png 750w,\n/static/353855dec58fcaa1477e90a869b30ad0/5a190/1*6NVMEmo0qDcQjpXcXI8dtg.png 800w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<hr>\n<blockquote>\n<ul>\n<li>\n<p>쿠버네티스는 구글이 지난 10여년 간 컨테이너를 프로덕션 환경에서 사용하면서 얻은 경험을 바탕으로 개발한 컨테이너-통합도구이다.</p>\n</li>\n<li>\n<p>여러 개의 호스트를 하나로 묶어 Docker를 이용하기 위한 오케스트레이션 툴</p>\n</li>\n</ul>\n</blockquote>\n<p>분산 환경에서 한 대의 컴퓨터처럼 투과적으로 컨테이너에 엑세스할 수 있다.</p>\n<p>시스템 이용자로부터 오는 부하의 급증에 대해 스케일하거나 여러 컨테이너를 효율적으로 통합 관리하는 장치도 있다.</p>\n<p>주요 기능들</p>\n<ul>\n<li>여러 서버들에서의 컨테이너 관리</li>\n<li>컨테이너 간 네트워크 관리</li>\n<li>컨테이너의 부하 분산</li>\n<li>컨테이너의 감시</li>\n<li>무정지로 업데이트</li>\n</ul>\n<h4>Kubernetes의 서버 구성</h4>\n<hr>\n<p><strong>Master Server</strong></p>\n<ul>\n<li>kubernetes 클러스터 안의 컨테이너를 조작하기 위한 server</li>\n</ul>\n<p>kubect1<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 명령을 사용하여 클러스터를 구성하거나 리소스를 조작할 때\nMaster Server가 command로부터 request를 받아 처리한다.\n클러스터 내의 노드의 리소스 사용 현황을 확인하고, 컨테이너를 시작할 노드를\n자동으로 선택한다. <strong>다중화를 검토</strong>할 필요가 있다.</p>\n<p><strong>Back-end Database(etcd)</strong></p>\n<ul>\n<li>분산 key-value store, 클러스터의 구성 정보를 관리한다.</li>\n</ul>\n<p>클러스터를 구축하기 위한 설정 정보가 들어 있다.</p>\n<p>시스템 구성에 따라서 etcd를 master server상에 구축하는 경우도 있다.\nmaster server와 마찬가지로 <strong>다중화를 검토</strong>할 필요가 있다.</p>\n<p><strong>Node</strong></p>\n<ul>\n<li>실제로 Docker container를 작동시키는 서버</li>\n</ul>\n<p>노드를 여러 개 마련하여 cluster를 구성한다. master server의 관리를 받는다.\n노드를 몇 대 마련할지는 시스템의 규모나 부하에 따라 달라진다.\n클라우드 환경에서는 Node 하나가 가상 머신의 인스턴스 하나가 된다.</p>\n<h4>Application 구성 관리</h4>\n<hr>\n<p>application 실행 환경의 orchestration 을 유연하게 수행하기 위해\n다양한 추상화를 하고 있다.</p>\n<p><strong>Pod</strong></p>\n<ul>\n<li>여러개의 컨테이너를 모아서 **'pod'**로 관리한다.</li>\n</ul>\n<p>app server용 컨테이너와 proxy server용 컨테이너 등 관련된 것들을 pod로 모은다.\nPod는 application의 <strong>Deployment 단위</strong>가 되며 Pod 단위로 컨테이너 작성/시작/정지/삭제\n와 같은 조작을 수행한다. 따라서 웹 프론트 서버와 데이터베이스 서버처럼 다른 기능을\n하나의 Pod에 저장하면 안된다.</p>\n<p>Pod는 반드시 동일한 노드 상에 동시에 전개된다. Pod 안의 여러 컨테이너가 가상 NIC(private IP)<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>를 공유하는 구성을 취하기 때문에 컨테이너끼리 localhost 경유로\n통신할 수 있다.</p>\n<p><strong>Replica Set</strong></p>\n<ul>\n<li>클러스터 상에 미리 지정된 Pod를 작성하여 실행시켜두는 장치</li>\n</ul>\n<p>클러스터 상에 정해진 수의 Pod를 반드시 실행시켜 둔다는 것\n실행중인 Pod를 감시하고 정지된 경우에 해당 Pod를 삭제하고, 새로운 Pod를 실행시킨다.\n클라우드 안에 pod를 얼마나 실행시켜 둘지를 **'Replica 수'**라고 한다.\npod의 수를 동적으로 변경하여 <strong>오토스케일</strong>을 구현할 수 있다.</p>\n<p><strong>Deployment</strong></p>\n<ul>\n<li>Pod와 ReplicaSet을 모은 것\nReplicaSet의 이력을 관리하는 것이다.</li>\n</ul>\n<p>ReplicaSet의 템플릿을 가지고 거기서 Pod의 구성을 정의하여 해당 템플릿을 따르는\nReplicaSet을 만든다. 이력을 관리할 수 있기 때문에 pod 안의 컨테이너의 버전업을\n하고 싶을 때 롤링 업데이트<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>를 하거나 이전 세대로 롤백할 수 있다. 기본적으로 <strong>'Blue-Green Deployment'</strong> 방법이 있다.</p>\n<p>이 외에도</p>\n<ul>\n<li><strong>DeamonSet</strong> : Node별로 감시 에이전트와 같은 특정 pod를 반드시 배치하고 싶을 때 사용</li>\n<li><strong>Jobs</strong> : 상주 서비스가 아닌 수치연산 처리와 같이 프로그램의 시작부터 종료까지로 완료되는 프로그램을 Pod에서 실행시킨다.</li>\n<li><strong>CronJob</strong> : Linux의 cron<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>과 같이 Pod를 실행시킬 타이밍을 지정한다.</li>\n</ul>\n<p>등의 관리 툴들이 있다.</p>\n<h4>Network 관리(Service)</h4>\n<hr>\n<p>클러스터 안에서 실행되는 Pod에 대해 외부로부터 엑세스할 때는 서비스를 정의한다.\n<strong>Service</strong>는 네트워크를 관리하는 것으로 종류가 다양하다.</p>\n<ul>\n<li><strong>Load Balancer</strong> : Service에 대응하는 IP 주소 + 포트번호에 엑세스하면 여러 Pod에 대한 L4 level의 로드벨런싱이 일어난다.</li>\n</ul>\n<p>Service에 할당되는 IP 주소는</p>\n<ul>\n<li><strong>Cluster IP</strong> : cluster 내부의 Pod끼리의 통신을 위한 Private IP\npod에서 보내는 패킷은 Node 상의 Proxy 데몬이 받아 수신 Pod로 전송된다.</li>\n<li><strong>External IP</strong> : 외부 client와 연결하기 위한 public IP 주소\nPod를 새로 실행하면 기존 서비스의 IP 주소와 포트 번호는 환경변수로 참조할 수 있다.</li>\n</ul>\n<p>Service 외에..</p>\n<p><strong>Ingress</strong>라는 pod에 대한 통신을 제어하는 기능이 있다. Ingress는 Service와 연결되어 통신 내용을 중계(proxy)한다. 이는 작동하는 환경에 따라 다른데, GCP의 경우\nHTTP Load Balancer를 사용한다. L7에서 작동하기 때문에 request url 별 분류나 virtual host 기능 등 보다 세세한 네트워크 제어를 할 수 있다.</p>\n<h4>Label을 사용한 리소스 식별</h4>\n<hr>\n<p>리소스를 식별하기 위해 내부에서 자동으로 랜덤한 이름이 부여됨\n이 이름으로 적절히 관리하기 어렵기 때문에 <strong>Label</strong>을 붙여서 관리한다.</p>\n<ul>\n<li>리소스를 식별하기 위한 Key-Value 형태의 임의의 문자열</li>\n</ul>\n<p>Label을 identifier로 하여 리소스를 일괄적으로 처리한다.</p>\n<p>Label은 하나의 리소스에 여러개를 설정할 수 있어서 Pod의 역할별로 임의의 이름을\n붙이거나 관련 있는 Pod 별로 모아서 유연하게 관리하고자 할때 유용하다.</p>\n<p>또한 <strong>매니페스트</strong> 라는 kubernetes의 정의 파일을 참조할 때도 사용됩니다.</p>\n<p>ex)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">labels:\n  app: v1.0\nselector:\n  type: webserver\n  app: v1.0</code></pre></div>\n<h4>Kubernetes의 구조</h4>\n<p>마스터, 데이터 스토어, 노드가 서로 협력하면서 컨테이너의 실행환경을 관리한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.93617021276594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACqklEQVQ4y22US2/TQBSF8ycQEj+Bn8EWsUJixwLYVaiiYs+WBVIlJFixQmoBiVYIaFVKq7ZBQKHPlNBnQpO0eTnOw4mfsT3zoXGcpKWMdHXHd2aOx+ee4wSAlNDPw5AXar3neDIYshdxPTEoyzOLcQgpIwARRyh6hyodj+mdMslMjbYPpgBbQiBkD7APpg45Abih/Ocm8lyuWgFji1VGlgxSmkum1GT5oE7Dg4SM3iyizXkT7n2X3ErCs31JqyvRHMmJJTkxJVUXLF9Q0Wo83wsZS8HbdJXltQzz6Q6N7plPVkMBv8zCpTeCqx/g2gI8SsHlKbgyDdfnHI5PSmhtm5Il0O0AwwcjgFYATggJwzAoFDUc245A8xbMlGAipbGledTskImNU15s1vh8VMeTkG8HPF7MMLlxgqmAJDQ8geVLErbZIrc1QVMv8ztboG55IG1mNw65u9hi5FuXO6+2+bW+SuhaZDWDSr3Fk1SX+2swe6CT3Mwyva5RVxy6jsPG6hy1apnDfJFctUG9mOPTscmNFbi5ArfnW/z4uYbv+xQaFnrb4vWfkPF9+Fq02S80SBU9Wn7UFBBnGqp50ArBUuH5FKs1bD8kVzM4KOo0/fMqDCS4EjwBoYxk09OcjNXrhypUg8ALoKw38AUoHdQNk1q1QtlweJeuRDrsKA7VXqkAY9n0wfras8ImbaGjd8ocZ47wJbG0QARdto4KPFwo8SBpsKO5HJw2WNjVezoc2msIuNScYVIbZ6r0kfcZP+Km4gzXnW7I092Q0W2YSmt8Wc+ytGdd1GHfMZ2Yp3QTRle7SqFobt/HMtJb0wOzKzAV1xLaAVjBOS8Pb9Dxe67YLlskt3Yp6G0qLjEtDH4GImqoRIhh/b+AKis/24HKYAfK+Ayadz4Y8K/mfwFCC2x2UYB5ZQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20190908135526253\"\n        title=\"image-20190908135526253\"\n        src=\"/static/fee970cb8a131bce1fb2356c848b43d6/1d69c/image-20190908135526253.png\"\n        srcset=\"/static/fee970cb8a131bce1fb2356c848b43d6/4dcb9/image-20190908135526253.png 188w,\n/static/fee970cb8a131bce1fb2356c848b43d6/5ff7e/image-20190908135526253.png 375w,\n/static/fee970cb8a131bce1fb2356c848b43d6/1d69c/image-20190908135526253.png 750w,\n/static/fee970cb8a131bce1fb2356c848b43d6/78797/image-20190908135526253.png 1125w,\n/static/fee970cb8a131bce1fb2356c848b43d6/aa440/image-20190908135526253.png 1500w,\n/static/fee970cb8a131bce1fb2356c848b43d6/a3c4c/image-20190908135526253.png 2196w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Master</strong></p>\n<ul>\n<li>\n<p><strong>API Server</strong></p>\n<p>kubernetes의 리소스 정보를 관리하기 위한 Front-end REST API</p>\n<p>각 component로부터 리소스 정보를 받아 etcd에 저장한다.</p>\n<p>component들은 etcd에 접근하기위해 API server를 거치고</p>\n<p>프로그래머는 웹의 GUI툴이나 kubectl 명령을 사용하고, app 내에서 API Server를 호출한다.</p>\n<p>인증, 인가 기능을 갖고 있음</p>\n</li>\n<li>\n<p><strong>Scheduler</strong></p>\n<p>Pod를 어떤 Node에서 작동시킬지 제어하는 Back-end component</p>\n<p>Node가 할당되지 않은 Pod를 클러스터의 상태를 확인하고 빈 영역을 가진 Node를 찾아</p>\n<p>실행시키는 스캐쥴링을 수행</p>\n</li>\n<li>\n<p><strong>Controller Manager</strong></p>\n<p>Kubernetes 클러스터의 상태를 항상 감시하는 Back-end Component</p>\n<p>정의 파일에서 정의한 것과 실제 Node나 Container에서 움직이고 있는 상태를 모아서 관리</p>\n</li>\n</ul>\n<p><strong>Data Store(etcd)</strong></p>\n<p>클러스터 구성을 유지 관리하는 KVS(key value store)</p>\n<p>어떤 pod를 어떻게 배치할지와 같은 구성 정보를 갖고 있으며 API server가 참조한다.</p>\n<p><strong>Node</strong></p>\n<ul>\n<li>\n<p><strong>kubelet</strong></p>\n<p>Node에서 작동하는 에이전트</p>\n<p>Pod의 정의 파일에 따라 Docker 컨테이너를 실행하거나 Storage를 마운트하는 기능을 갖는다.</p>\n<p>Node의 status를 정기적으로 감시하는 기능을 갖고, status가 변경되면 API server에게 알린다.</p>\n</li>\n</ul>\n<p>kubernetes의 클러스터 구성정보를 YAML이나 JSON으로 관리하는데 이 정의파일을\n<strong>Manifest file</strong>이라고 한다. Jenkins와 같은 소프트웨어 버전관리 시스템과 연계할 수 있다.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">Kubectl 는 쿠버네티스 클러스터를 조작하기 위한 cli이다. <a href=\"https://kubernetes.io/docs/reference/kubectl/overview/\">kubect1 overview</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">(Network Interface Controller) Host에서 network와의 연결을 담당하는 인터페이스 역할을 하는 장치, 여기서는 L2 switch를 의미하는 듯 하다.<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">(무중단배포)Pod 인스턴스를 점진적으로 새로운 것으로 업데이트하여 디플로이먼트 업데이트가 서비스 중단 없이 이루어질 수 있도록 해준다.<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">운영체제의 시간 기반 Job scheduler. 작업을 고정된 시간, 날짜, 간격에 주기적으로 실행할 수 있도록 스케줄링하기위해 사용(특정시간마다 log 분석 등을 할때 유용할듯)<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>"}},"pageContext":{"slug":"Docker-K8S-1"}},
    "staticQueryHashes": ["3159585216","440568431"]}